/**
 * Selector Generator
 * Generates unique, stable CSS selectors for elements
 */

/**
 * Generate a unique CSS selector for an element
 * Prioritizes: ID > data-testid > aria-label > unique class > nth-child path
 */
export function generateSelector(element: HTMLElement): string {
  // Try ID first (most stable)
  if (element.id && isValidId(element.id)) {
    return `#${CSS.escape(element.id)}`
  }

  // Try data-testid (common in modern apps)
  const testId = element.getAttribute('data-testid') || element.getAttribute('data-test-id')
  if (testId) {
    return `[data-testid="${CSS.escape(testId)}"]`
  }

  // Try aria-label (accessible and stable)
  const ariaLabel = element.getAttribute('aria-label')
  if (ariaLabel && ariaLabel.length < 50) {
    return `[aria-label="${CSS.escape(ariaLabel)}"]`
  }

  // Try name attribute for form elements
  if (element instanceof HTMLInputElement || element instanceof HTMLSelectElement) {
    const name = element.getAttribute('name')
    if (name) {
      return `${element.tagName.toLowerCase()}[name="${CSS.escape(name)}"]`
    }
  }

  // Try unique class combination
  const classSelector = getUniqueClassSelector(element)
  if (classSelector) {
    return classSelector
  }

  // Fall back to path-based selector
  return getPathSelector(element)
}

/**
 * Check if an ID is valid and not auto-generated
 */
function isValidId(id: string): boolean {
  // Skip IDs that look auto-generated
  const autoGeneratedPatterns = [
    /^:r[0-9a-z]+:$/i, // React generated
    /^ember\d+$/i, // Ember generated
    /^[0-9a-f]{8}-[0-9a-f]{4}/i, // UUID-like
    /^\d+$/, // Pure numbers
    /^_[0-9a-z]+$/i, // Underscore prefixed
  ]

  return !autoGeneratedPatterns.some((pattern) => pattern.test(id))
}

/**
 * Try to find a unique class-based selector
 */
function getUniqueClassSelector(element: HTMLElement): string | null {
  const classes = Array.from(element.classList)
    .filter((cls) => !isAutoGeneratedClass(cls))
    .slice(0, 3) // Limit to 3 classes

  if (classes.length === 0) return null

  const tag = element.tagName.toLowerCase()

  // Try combinations of classes
  for (let i = 1; i <= classes.length; i++) {
    const selector = `${tag}.${classes.slice(0, i).map(CSS.escape).join('.')}`
    const matches = document.querySelectorAll(selector)
    if (matches.length === 1) {
      return selector
    }
  }

  return null
}

/**
 * Check if a class looks auto-generated
 */
function isAutoGeneratedClass(className: string): boolean {
  const patterns = [
    /^css-[a-z0-9]+$/i, // Emotion/styled-components
    /^sc-[a-z0-9]+$/i, // Styled-components
    /^_[a-z0-9]+$/i, // CSS modules
    /^[a-z]+-[a-z0-9]{5,}$/i, // Generic hash-based
    /^svelte-[a-z0-9]+$/i, // Svelte
  ]

  return patterns.some((pattern) => pattern.test(className))
}

/**
 * Generate a path-based selector using nth-child
 */
function getPathSelector(element: HTMLElement): string {
  const path: string[] = []
  let current: HTMLElement | null = element

  while (current && current !== document.body && path.length < 5) {
    let selector = current.tagName.toLowerCase()

    // Add nth-child for disambiguation
    const parent = current.parentElement
    if (parent) {
      const siblings = Array.from(parent.children).filter(
        (child) => child.tagName === current!.tagName
      )
      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1
        selector += `:nth-child(${index})`
      }
    }

    path.unshift(selector)
    current = current.parentElement
  }

  return path.join(' > ')
}

/**
 * Validate that a selector matches only the target element
 */
export function validateSelector(selector: string, element: HTMLElement): boolean {
  try {
    const matches = document.querySelectorAll(selector)
    return matches.length === 1 && matches[0] === element
  } catch {
    return false
  }
}
